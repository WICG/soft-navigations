<pre class=metadata>
Title: Task Attribution
Status: CG-DRAFT
Shortname:task-attribution
Group: wicg 
Level: none
Editor: Yoav Weiss, Google https://google.com, yoav@yoav.ws, w3cid 58673

URL: https://wicg.github.io/soft-navigation/task-attribution.html
Repository: https://github.com/WICG/soft-navigation
Test Suite: https://github.com/web-platform-tests/wpt/tree/master/soft-navigation-heuristics
Abstract: This document defines infrastructure to enable browsers to know which tasks are ancestors for other tasks.
Default Highlight: js
Complain About: accidental-2119 yes
</pre>

<pre class=anchors>
urlPrefix: https://html.spec.whatwg.org/multipage/; spec: HTML;
    type: dfn; url: #queue-a-task; text: queueing a task;
</pre>

Introduction {#sec-intro}
=====================

<div class="non-normative">

<em>This section is non-normative.</em>

The user agentâ€™s event loop is continuously running tasks, as well as microtasks.
Being able to keep track of which task initiated which can be valuable in multiple cases:
* Enable user agents to create heuristics that rely on causal link between one operation (e.g. a user initiated click event) and another (e,g. a DOM modification).
* Enable user agents to make prioritization (of tasks as well as resource loading) "inheritable", and e.g. ensure that low-priority scripts cannot queue high-priority tasks.
* Enable causal user activation delegaion.
* Enable userland recreation of resource loading dependency chains.

This specification outlines a mechanism that would enable user agents to deduce that information, and use it in various other algorithms that might be used for web exposed features.
However, this specification does not define a web exposed feature in and of itself.

ISSUE: Should we discuss potential conncetion with AsyncContext and its use cases?

</div>

Task Attribution {#sec-task-attribution}
========================

High-level design {#sec-design}
------------------------
The general principle behind task attribution is quite simple:
* Script execution creates a task scope
* Tasks and microtasks that are queued during a task scope's lifetime are considered its descendents.
* Some registered callbacks get an explicit parent task defined. (e.g. the task that registered the callback)

The relationship between the various tasks is then kept in a container that enables the user agent to quickly determine if the current task is a descendant of another, specific one.

Algorithms {#sec-algorithms}
-------------------------

Open questions:
* Should TaskAttribution live on the env settings object? On the event loop itself? Somewhere else?


Rough outline:
* Add a hashmap to the env settings object that stores task IDs.
* Keep the current task ID
* When a new task is queued, it gets added to the hashmap with its parent. Its parent has it added as a direct descendent

### Task termination {#sec-task-termination}
Each Task has a parent and number of direct descendants
When a task is done and has no living children, it notifies its parent and gets removed from the container.
When a task is notified and has no living child tasks, it's also notifies its parent.


### Create a task scope {#sec-create-task-scope}
Add 

### Track task queueing {#sec-track-task-queueing}

### Is ancestor {#sec-is-ancestor}


HTML integration {#sec-integration}
-------------------------

Create a task scope before a script is executed
* Initial script execution
* Before specific event callbacks

When <a>queueing a task</a>, add it to the container.

Security & privacy considerations {#priv-sec}
===============================================
As this infrastructure doesn't directly expose any data to the web, it doesn't have any privacy and security implications.
Web exposed specifications that rely on this infrastructure might have such implications. As such, they need to be individually examined and have those implications outlined.

