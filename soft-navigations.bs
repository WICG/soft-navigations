<pre class=metadata>
Title: Soft Navigations
Status: CG-DRAFT
Shortname:soft-navigations
Group: wicg
Level: none
Editor: Yoav Weiss, Google https://google.com, yoav@yoav.ws, w3cid 58673
URL: https://wicg.github.io/soft-navigations/
Repository: https://github.com/WICG/soft-navigations
Test Suite: https://github.com/web-platform-tests/wpt/tree/master/soft-navigation-heuristics
Abstract: This document defines a heuristic that would enable browsers to report metrics related to Single Page Apps soft navigations.
Boilerplate: omit conformance
Default Highlight: js
Complain About: accidental-2119 yes
Markup Shorthands: markdown on
</pre>

<pre class=anchors>
urlPrefix: https://html.spec.whatwg.org/C; spec: HTML;
    type: dfn; url: #execute-the-script-element; text: execute the script element;
    type: dfn; url: #update-document-for-history-step-application; text: update document for history step application;
    type: dfn; url: #top-level-traversable; text: top-level traversable;
    type: dfn; url: #timer-initialisation-steps; text: timer initialisation steps;
    type: dfn; url: #hostmakejobcallback; text: HostMakeJobCallback;
urlPrefix: https://dom.spec.whatwg.org/; spec: DOM;
    type: dfn; url: #concept-event-dispatch; text: event dispatch;
    type: dfn; url: #concept-node-insert; text: node insert;
    type: dfn; url: #dom-event-istrusted; text: isTrusted;
</pre>
<pre class=link-defaults>
</pre>

Introduction {#sec-intro}
=====================

<div class="non-normative">
<em>This section is non-normative.</em>

Single Page App or SPA is a common web development pattern on the web today, but also one that browsers haven't been able to measure performance metrics for.
Specifically, JS-driven same-document navigations in SPAs have not been something that browsers detect, and hence went unmeasured.

This specification outlines a heuristic to enable browsers to detect such navigations as Soft Navigations, and report them to the performance timeline and performance observers.
</div>

Task Attribution {#sec-task-attribution-intro}
-----------------

<div class="non-normative">
The above heuristic relies on the ability to track task ancestory and to know that certain tasks were triggered by other tasks.
This specification also outlines a mechanism that would enable user agents to deduce that information, and use it in web exposed features, such as soft navigations.

The user agentâ€™s event loop is continuously running tasks, as well as microtasks.
Being able to keep track of which task initiated which can be valuable in multiple cases:
  * Enable user agents to create heuristics that rely on causal link between one operation (e.g. a user initiated click event) and another (e,g. a DOM modification).
  * Enable user agents to make prioritization (of tasks as well as resource loading) "inheritable", and e.g. ensure that low-priority scripts cannot queue high-priority tasks.
  * Enable causal user activation delegation.
  * Enable accumulating knowledge of resource loading dependency chains, and enable developers to draw insights from them.

</div>
ISSUE: Should we discuss potential connection with AsyncContext and its use cases?

Algorithms {#sec-algos}
=====================

<div class=note>
A Soft Navigation is a same document navigation which satisfies the following conditions:
  * Its navigating task is a descendent of a user interaction task.
  * There exists a DOM modification operation whose task is a descendent of the same user interaction task.
    </div>

To <dfn>check soft navigation</dfn>, with a [=Document=] |doc|, run the following steps:
* If |doc|'s [=soft navigation same document commit=] is true and |doc|'s [=soft navigation DOM modification=] is true, call [=emit soft navigation entry=] with |doc|.

To <dfn>emit soft navigation entry</dfn>, with a [=Document=] |doc|, run the following steps:

  * Queue an entry
  * Add an entry to the performance timeline
  * Reset LCP flags
  * Reset FP/FCP flags.
  * Reset the doc's flag

TODO: Actually define all the above.

HTML integration {#sec-html}
=================

Document {#sec-html-document}
----------

Each [=document=] has a <dfn for=document>potential soft navigation task id</dfn>, a [=task attribution ID=].

Each [=document=] has a <dfn for=document>soft navigation same document commit</dfn> flag, initially unset.

Each [=document=] has a <dfn for=document>soft navigation DOM modification</dfn> flag, initially unset.

In [=update document for history step application=], add the following steps before 5.5.1 (if `documentsEntryChanged` is true and if `documentIsNew` is false):
* Let <a>document</a>'s [=soft navigation same document commit=] be the result of [=Check ancestor for task=] with the document's soft navigation ID and the result of calling [=get current task ID=].
* Call [=check soft navigation=].

At [=event dispatch=], after step 5.4 ("Let `isActivationEvent` be true..."), add the following step:
* If <var ignore>isActivationEvent</var> is true, and <var ignore>event</var>'s [=isTrusted=] is true, and |target|'s [=associated Document=] is a [=top-level traversable=],
    let |target|'s [=associated Document=]'s [=potential soft navigation task id=] be the result of calling [=get current task ID=].


At [=node insert=], add these initial steps:
* Let |doc| be <var ignore>parent</var>'s [=node document=].
* Let |doc|'s [=soft navigation DOM modification=] be the result of running [=Check ancestor for task=] with the |doc|'s [=potential soft navigation task id=] and the result of calling [=get current task ID=].
* Call [=check soft navigation=].


Task Attibution Algorithms {#sec-task-attribution-algorithms}
=========================

The general principle behind task attribution is quite simple:
  * Script execution creates a task scope
  * Tasks and microtasks that are queued during a task scope's lifetime are considered its descendents.
  * Certain registered callbacks get an explicit parent task defined. (e.g. the task that registered the callback)

Each task maintains a connection to its parent task, enabling an implicit data structure that enables querying a task to find if another, specific one is its ancestor.


## Task scope ## {#sec-task-scope}


A <dfn id=concept-task-scope>task scope</dfn> is formally defined as a structure.

A [=task scope=] has a <dfn for="task scope">task</dfn>, a [=/task=].

To <dfn>create a task scope</dfn>, given an optional |parent task|, a [=/task=], do the following:
  1. Let |task| be a new [=/task=].
  1. Set |task|'s [=task attribution ID=] to an [=implementation-defined=] unique value.
  1. If |parent task| is provided, set |task|'s [=parent task=] to |parent task|.
  1. Let |scope| be a new [=task scope=].
  1. Set |scope|'s [=task scope/task=] to |task|.
  1. Push |scope| to the [=relevant agent=]'s [=agent/event loop=]'s [=task scope stack=].


To <dfn>tear down a task scope</dfn>, do the following:
  1. Pop |scope| from the [=relevant agent=]'s [=agent/event loop=]'s [=task scope stack=]

## Is ancestor ## {#sec-is-ancestor}
To <dfn export>check ancestor for task</dfn>, given |ancestor id|, a [=task attribution ID=], run the following:
  1. Let |task| be the result of [=get current task=].
  1. While true:
    1. Let |id| be|task|'s [=task attribution ID=].
    1. If |id| is unset, return false.
    1. If |id| equals |ancestor id|, return true.
    1. Set |task| to |task|'s [=parent task=].

## Is ancestor in set ## {#sec-is-ancestor-in-set}

To <dfn export>check ancestor set for task</dfn>, given |ancestor id set|, a [=task attribution ID=] [=/set=], run the following:
  1. Let |task| be the result of [=get current task=].
  1. While true:
    1. Let |id| be |task|'s [=task attribution ID=] if |task| is set, or be unset otherwise.
    1. If |id| is unset, return false.
    1. If |ancestor id set| [=contains=] |id|, return true.
    1. Set |task| to |task|'s [=parent task=].

### Get current task ### {#sec-current-task}
To <dfn export>get current task</dfn>, run the following steps:
  1. Let |event loop| be the [=relevant agent=]'s [=agent/event loop=].
  1. Let |scope| be the result of [=peeking=] into the |event loop|'s [=task scope stack=].
  1. Return |scope|'s [=task scope/task=].

### Get current task ID ### {#sec-current-task-id}
To <dfn export>get current task id</dfn>, run the following steps:
  1. Let |task| be the result of [=getting current task=].
  1. Return |task|'s [=task attribution ID=].

TaskAttribution HTML integration {#sec-task-attribution-integration}
================================

## Task additions  ## {#sec-task}

A [=/task=] has a <dfn for="task">task attribution ID</dfn>, an [=implementation-defined=] value,
representing a unique identifier. It is initially unset.

A [=/task=] has a <dfn for="task">parent task</dfn>, a [=/task=], initially unset.

## Event Loop additions ##{#sec-event-loop}
Each [=/event loop=] has a <dfn>task scope stack</dfn>, a [=stack=] of <a>task scopes</a>.

## Script execution ##{#sec-script}
In [=Execute the script element=], add initial steps:
  1. [=Create a task scope=].

Also, add a terminating step:
  1. [=Tear down a task scope=]

TODO: Handle parent scope passing for executing scripts.

TODO: investigate "prepare to run a script"

## Task queueing ##{#sec-task-queueing}
In [=queue a task=]:

Add these steps after step 3, "Let task be a new task":
  1. Set |task|'s [=parent task=] to the result of [=getting current task ID=].
  1. [=Create a task scope=] with |task|.

Add a terminating step:
  1. [=Tear down a task scope=]

TODO: Do we need this both when queueing a task and when calling a callback?

## Timers ##{#sec-timers}
In [=timer initialisation steps=], before step 8, add the following steps:
  1. Let |parent task| be the result of [=getting current task=].
  1. If |handler| is a Function, set |handler|'s parent task to |parent task|.
  1. Otherwise, [=create a task scope=] with |parent task|..

TODO: How do we properly set the parent task on the callback function??

## Callbacks ##{#sec-callbacks}
In [=prepare to run a callback=], add the following steps::
  1. Let |task| be <var ignore>callback</var>'s parent task
  1. [=create a task scope=] with |task| if set, and with nothing otherwise.

<p class=note>
The above is called from both promise continuations and from "regular" script callbacks.
That does not match Chromium where Blink is not notified when promise continuations are run inside of V8.
This is subtly different than what's implemented in Chromium, as there the continuation task overrides
the task stack, where here it pushes a new child task of itself onto that stack.
At the same time, there shouldn't be any functional differences between the two.
</p>


In [=clean up after running a callback=], add the following step:
  1. [=Tear down a task scope=].

## HostMakeJobCallback ##{#sec-hostmakejobcallback}
In [=HostMakeJobCallback=], add the following steps:
  1. Let |task| be the result of [=getting current task=].
  1. Let <var ignore>callable</var>.[task] be |task|.

Note: This is needed to ensure the current task is registered on the promise resolvers when they are created.


## Other ##{#sec-other}

TODO: handle postmessages

TODO: handle same document navigations

TODO: other cases?? (rAF, rIC, view transitions, observers, JS loading, etc)


Security & privacy considerations {#priv-sec}
===============================================
Exposing Soft Navigations to the performance timeline doesn't have security and privacy implications on its own.
However, reseting the various paint timing entries as a result of a detected soft navigation can have implications,
especially before [visited links are partitioned](https://github.com/kyraseevers/Partitioning-visited-links-history).
As such, exposing such paint operations without partitioning the :visited cache needs to only be done after careful
 analysis of the paint operations in question, to make sure they don't expose the user's history across origins.

Task Attribution as infrastructure doesn't directly expose any data to the web, so it doesn't have any privacy and security implications.
Web exposed specifications that rely on this infrastructure could have such implications. As such, they need to be
individually examined and have those implications outlined.

